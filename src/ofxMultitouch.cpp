#include "ofxMultitouch.h"

#ifdef TARGET_WIN32
// static touch events
ofEvent<ofTouchEventArgs>	ofxMultitouch::touchDown;
ofEvent<ofTouchEventArgs>	ofxMultitouch::touchUp;
ofEvent<ofTouchEventArgs>	ofxMultitouch::touchMoved;
ofEvent<ofMouseEventArgs>	ofxMultitouch::mouseButtonDown;
ofEvent<ofMouseEventArgs>	ofxMultitouch::mouseButtonUp;

// I'm using [O] to diferentiate my own comments from that of the original author who made ofxWinTouchHook
// There's a lot going on here and I don't want to further confuse things

// [O] General info on hooks:
// https://docs.microsoft.com/en-us/windows/win32/api/winuser/nf-winuser-setwindowshookexa

#include <Windows.h>

// variable to store the HANDLE to the hook. Don't declare it anywhere else then globally
// or you will get problems since every function uses this variable.
HHOOK _hook;

// This struct contains the data received by the hook callback. As you see in the callback function
// it contains the thing you will need: vkCode = virtual key code.
KBDLLHOOKSTRUCT kbdStruct;

// This is the callback function. Consider it the event that is raised when, in this case, 
// a key is pressed.
// [O] This seems to be using LowLevelKeyboardProc callback, described here:
// https://docs.microsoft.com/en-us/previous-versions/windows/desktop/legacy/ms644985(v%3Dvs.85)
LRESULT __stdcall HookCallback(int nCode, WPARAM wParam, LPARAM lParam) {
	if (nCode >= 0) {

#ifdef USE_WM_POINTER_EVENTS
		LPMSG pStruct = (LPMSG)lParam;
		UINT message = pStruct->message;

		switch (message) {
		case WM_LBUTTONDOWN: { //TODO Consolidate LBUTTON cases
			// [O] Read about WN_LBUTTONDOWN and other system gestures here:
			// https://docs.microsoft.com/en-us/windows/win32/tablet/system-events-and-mouse-messages

			const LONG_PTR c_SIGNATURE_MASK = 0xFFFFFF00;
			const LONG_PTR c_MOUSEEVENTF_FROMTOUCH = 0xFF515700;

			LONG_PTR extraInfo = GetMessageExtraInfo();
			int isTouch = ((extraInfo & c_SIGNATURE_MASK) == c_MOUSEEVENTF_FROMTOUCH);
			if (!isTouch) {
				ofMouseEventArgs mouseEventArgs; // TODO could be cool to actually send over the mouse coordinates here, haha
												 // (and by that I mean this really needs to get done)
				ofNotifyEvent(ofxMultitouch::mouseButtonDown, mouseEventArgs);
			}

			break;
		}
		case WM_LBUTTONUP: {
			const LONG_PTR c_SIGNATURE_MASK = 0xFFFFFF00;
			const LONG_PTR c_MOUSEEVENTF_FROMTOUCH = 0xFF515700;

			LONG_PTR extraInfo = GetMessageExtraInfo();
			int isTouch = ((extraInfo & c_SIGNATURE_MASK) == c_MOUSEEVENTF_FROMTOUCH);
			if (!isTouch) {
				ofMouseEventArgs mouseEventArgs;
				ofNotifyEvent(ofxMultitouch::mouseButtonUp, mouseEventArgs);
			}

			break;
		}
		case WM_POINTERDOWN:
		case WM_POINTERUPDATE:
		case WM_POINTERUP:
			POINTER_INFO pointerInfo = {};
			// Get frame id from current message
			if (GetPointerInfo(GET_POINTERID_WPARAM(pStruct->wParam), &pointerInfo)) {
				POINT p = pointerInfo.ptPixelLocation;

				// TODO I can't remember, but the following blocks might be old and irrelevant
				// Maybe they didn't work because they aren't right, but maybe it was when VS decided
				// to run the debugger on an old version of the build for some dumb reason
				// Either way, check this out at some point and either add it in or delete it
				/* Pointer types:
				https://docs.microsoft.com/en-us/windows/win32/api/winuser/ne-winuser-tagpointer_input_type

				typedef enum tagPOINTER_INPUT_TYPE {
				  PT_POINTER,
				  PT_TOUCH,
				  PT_PEN,
				  PT_MOUSE,
				  PT_TOUCHPAD
				} ;

				So, we're looking for the pointers that have pointerType PT_TOUCH
				*/

				/*ofLog() << pointerInfo.pointerType;
				if (pointerInfo.pointerType == PT_TOUCH) {
					ofLog() << "Touch!";
				}*/

				// native touch to screen conversion, alt use ofGetWindowPosition offsets
				ScreenToClient(pStruct->hwnd, &p);

				ofTouchEventArgs touchEventArgs;
				touchEventArgs.x = p.x;
				touchEventArgs.y = p.y;
				touchEventArgs.id = pointerInfo.pointerId;

				if (pointerInfo.pointerFlags & POINTER_FLAG_DOWN) {
					ofNotifyEvent(ofxMultitouch::touchDown, touchEventArgs);
				}
				else if (pointerInfo.pointerFlags & POINTER_FLAG_UPDATE) {
					ofNotifyEvent(ofxMultitouch::touchMoved, touchEventArgs);
				}
				else if (pointerInfo.pointerFlags & POINTER_FLAG_UP) {
					ofNotifyEvent(ofxMultitouch::touchUp, touchEventArgs);
				}
			}

			break;
		}


#else

		// this doesnt fire with WH_CALLWNDPROC, as it's before the message is processed
		// http://cinematography-project-m2-charles.googlecode.com/svn/trunk/Touch2Tuio/TouchHook/TouchHook.cpp
		// WM_TOUCH only
		/*LPMSLLHOOKSTRUCT msg = (LPMSLLHOOKSTRUCT)lParam;
		if (msg->flags & LLMHF_INJECTED) // block injected events (in most cases generated by touches)
		{
			printf("\nBlocked injected (touch) mouse event %d", wParam);
			//sprintf_s(s_buf, "Blocked injected (touch) mouse event\n");
			//WriteConsole(s_out, s_buf, strlen(s_buf), &s_ccount, 0);
			//return CallNextHookEx(0, nCode, wParam, lParam);
			return 0;
		}*/

		// wm_touch/win7
		PCWPSTRUCT pStruct = (PCWPSTRUCT)lParam;
		UINT message = pStruct->message;// ((PCWPSTRUCT)lParam)->message;

		if (message == WM_TOUCH) {

			POINT p;
			UINT numInputs = (UINT)pStruct->wParam; // Number of actual per-contact messages
			TOUCHINPUT* touchInput = new TOUCHINPUT[numInputs]; // Allocate the storage for the parameters of the per-contact messages

			// Unpack message parameters into the array of TOUCHINPUT structures, each
			// representing a message for one single contact.
			HTOUCHINPUT touchLParam = (HTOUCHINPUT)pStruct->lParam;
			if (GetTouchInputInfo(touchLParam, numInputs, touchInput, sizeof(TOUCHINPUT)))
			{
				// For each contact, dispatch the message to the appropriate message
				// handler.
				for (unsigned int i = 0; i < numInputs; ++i)
				{
					// Capture x,y of touch event before iteration through objects
					p.x = TOUCH_COORD_TO_PIXEL(touchInput[i].x);// (touchInput[i].x) / 100;
					p.y = TOUCH_COORD_TO_PIXEL(touchInput[i].y);//(touchInput[i].y) / 100;

					// native touch to screen conversion, alt use ofGetWindowPosition offsets
					ScreenToClient(pStruct->hwnd, &p);

					// OF touch event (only using x,y,and id)
					// only interested in basic down, move, and up events
					ofTouchEventArgs touchEventArgs;
					touchEventArgs.x = p.x;
					touchEventArgs.y = p.y;
					touchEventArgs.id = touchInput[i].dwID;

					if (touchInput[i].dwFlags & TOUCHEVENTF_DOWN)
					{
						//printf("\nDOWN %ld %ld", p.x, p.y);						
						//ofNotifyEvent(ofEvents().touchDown, touchEventArgs);
						ofNotifyEvent(ofxMultitouch::touchDown, touchEventArgs);
					}
					else if (touchInput[i].dwFlags & TOUCHEVENTF_MOVE)
					{
						//printf("\nMOVE %ld %ld", p.x, p.y);
						//ofNotifyEvent(ofEvents().touchMoved, touchEventArgs);
						ofNotifyEvent(ofxMultitouch::touchMoved, touchEventArgs);
					}
					else if (touchInput[i].dwFlags & TOUCHEVENTF_UP)
					{
						//printf("\nUP %ld %ld", p.x, p.y);
						//ofNotifyEvent(ofEvents().touchUp, touchEventArgs);
						ofNotifyEvent(ofxMultitouch::touchUp, touchEventArgs);
					}

				}
			}
			CloseTouchInputHandle(touchLParam);
			delete[] touchInput;

		}
#endif

	}

	// call the next hook in the hook chain. This is necessary or your hook chain will break and the hook stops
	return CallNextHookEx(_hook, nCode, wParam, lParam);
}


#elif defined(TARGET_LINUX)
MultitouchReader ofxMultitouch::multitouchReader;
#endif

//--------------------------------------------------------------
void ofxMultitouch::EnableTouch() {

#ifdef TARGET_WIN32

	// for WM_pointer events
#ifdef USE_WM_POINTER_EVENTS

	// WM_pointer not working
	EnableMouseInPointer(FALSE);
	int windowsHookCode = WH_GETMESSAGE;

#else

// for WM_TOUCH - win7+8
	RegisterTouchWindow(ofGetWin32Window(), TWF_WANTPALM);
	int windowsHookCode = WH_CALLWNDPROC;

#endif

	// Set the hook and set it to use the callback function above
	// WH_KEYBOARD_LL means it will set a low level keyboard hook. More information about it at MSDN.
	// The last 2 parameters are NULL, 0 because the callback function is in the same thread and window as the
	// function that sets and releases the hook. If you create a hack you will not need the callback function 
	// in another place then your own code file anyway. Read more about it at MSDN.
	//if (!(_hook = SetWindowsHookEx(WH_MOUSE_LL, HookCallback, NULL, 0)))
	//hook = SetWindowsHookEx(WH_CALLWNDPROC, LaunchListener, thisModule, threadID);
	// catch before window: http://stackoverflow.com/questions/21069643/is-it-possible-to-remove-touch-messages-wm-pointerdown-etc-that-an-applicatio
	// WM_pointer events will come through on the WH_GETMESSAGE hook - windowsHookCode
	// WM_TOUCH messages will come through on the WH_CALLWNDPROC hook - windowsHookCode
	if (!(_hook = SetWindowsHookEx(windowsHookCode, HookCallback, GetModuleHandle(NULL), GetCurrentThreadId()))) {
		//MessageBox(NULL, "Failed to install hook!", "Error", MB_ICONERROR);
		ofLogError() << "Failed to install hook!";
	}

#elif defined(TARGET_LINUX)
	multitouchReader.startMultitouch();
#else
	ofLog() << "Not a Windows or Linux target";
#endif
}

void ofxMultitouch::DisableTouch() {

#ifdef TARGET_WIN32
	UnhookWindowsHookEx(_hook);
#elif defined(TARGET_LINUX)
	multitouchReader.stopMultitouch();
#endif
}
